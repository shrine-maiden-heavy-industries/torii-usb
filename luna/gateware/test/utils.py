#
# This file is part of LUNA.
#
""" Boilerplate for LUNA unit tests. """

import os
import unittest

from functools import wraps

from nmigen.test.utils import FHDLTestCase
from nmigen.back.pysim import Simulator


def sync_test_case(process_function):
    """ Decorator that converts a function into a simple synchronous-process test case. """

    #
    # This function should automatically transform a given function into a pysim
    # synch process _without_ losing the function's binding on self. Accordingly,
    # we'll create a wrapper function that has self bound, and then a test case
    # that's closed over that wrapper function's context. 
    #
    # This ensure that self is still accessible from the decorated function.
    #

    def run_test(self):
        @wraps(process_function)
        def test_case():
            yield from self.initialize_signals()
            yield from process_function(self)

        self.sim.add_sync_process(test_case)
        self.simulate(vcd_suffix=process_function.__name__)

    return run_test


class LunaGatewareTestCase(FHDLTestCase):

    # Convenience property: if set, instantiate_dut will automatically create
    # the relevant fragment with FRAGMENT_ARGUMENTS.
    FRAGMENT_UNDER_TEST = None
    FRAGMENT_ARGUMENTS = {}

    # Convenience property: if not None, a clock with the relevant frequency
    # will automatically be added.
    CLOCK_FREQUENCY = 60e6


    def instantiate_dut(self):
        """ Basic-most function to instantiate a device-under-test.

        By default, instantiates FRAGMENT_UNDER_TEST.
        """
        self.dut = self.FRAGMENT_UNDER_TEST(**self.FRAGMENT_ARGUMENTS)


    def get_vcd_name(self):
        """ Return the name to use for any VCDs generated by this class. """
        return "test_{}".format(self.__class__.__name__)


    def setUp(self):
        self.instantiate_dut()
        self.sim = Simulator(self.dut)

        if self.CLOCK_FREQUENCY:
            self.sim.add_clock(1 / self.CLOCK_FREQUENCY)


    def initialize_signals(self):
        pass


    def simulate(self, *, vcd_suffix=None):
        """ Runs our core simulation. """

        # If we're generating VCDs, run the test under a VCD writer.
        if os.getenv('GENERATE_VCDS', default=False):

            # Figure out the name of our VCD files...
            vcd_name = self.get_vcd_name()
            if vcd_suffix:
                vcd_name = "{}_{}".format(vcd_name, vcd_suffix)

            # ... and run the simulation while writing them.
            with self.sim.write_vcd(vcd_name + ".vcd", vcd_name + ".gtkw"):
                self.sim.run()

        else:
            self.sim.run()


    @staticmethod
    def pulse(signal):
        """ Helper method that asserts a signal for a cycle. """
        yield signal.eq(1)
        yield
        yield signal.eq(0)
        yield


    @staticmethod
    def advance_cycles(cycles):
        """ Helper methods that waits for a given number of cycles. """

        for _ in range(cycles):
            yield
